#!/usr/bin/php
<?

// -- BASICS

	define("ROOT", realpath(__DIR__.'/..'));
	define("NAME", basename($_SERVER['SCRIPT_NAME']));

	require_once ROOT."/etc/init.d/pre-cli.php";
	require_once ROOT."/etc/init.d/core.php";
	require_once ROOT."/lib/include/core.cli.php";

// -- CLASSES

	// Options container
	abstract class CLIOptions extends YacmsCLIOptions
	{
		/* Override for console options parent
		 * @return void
		 */
		public static function init()
		{
			self::$opts = array(
				"env"   => array(
					"value" => false,
					"short" => 'e',
					"desc"  => 'Use this environment',
				),
				"force"   => array(
					"value" => false,
					"short" => 'f',
					"desc"  => 'Force action',
				),
				"help"   => array(
					"value" => false,
					"short" => 'h',
					"desc"  => 'Show this help',
				),
				"verbose" => array(
					"value" => false,
					"short" => 'v',
					"desc"  => 'Talkative mode',
				),
				"command" => array(
					"value" => null
				),
				"params"  => array(
					"value" => array()
				),
			);

			self::$commands = array(
				"broken"    => 'List all ya-files that have been changed since install',
				"browse"    => 'Get list of all available packages',
				"files"     => array(
					'single' => "List all installed files",
					'prefix' => "List all installed files with prefix",
				),
				"install"   => array(
					'packages' => "Install packages"
				),
				"installed" => 'Get list of installed ya-packages',
				"repo"      => 'Get list of available configured repositories',
				"sync"      => array(
					"single" => 'Reload package list from all repositories',
					"repo repo"   => 'Reload package list from selected repositories'
				),
				"updates"   => array(
					'single' => "Get list of available stable versions",
					'branch' => "Get list of available versions from this branch",
				),
				"upgrade"   => array(
					'single'   => "Upgrade all packages to the latest version",
					'packages' => "Upgrade packages",
//					'version'  => "Update to this version. Format: branch/version or branch/latest",
				),
			);

			self::$info = array(
				"name" => NAME,
				"head" =>
					'Santa package manager'.NL.
					'Internal package manager for YaWF system'.NL,

				"foot" => 'Santa will always skip upgrades from testing branch. It will also suggest upgrades only from packages\' branch'.NL,
			);
		}
	}


	abstract class CLICommands extends YacmsCLICommands
	{
		public static function repo()
		{
			System\Init::basic();
			out_flist(System\Santa::get_repo_list());
		}


		public static function sync()
		{
			\System\Init::Basic();
			$list = \System\Santa::get_repo_list();
			$sync = array();
			$params = YacmsCLIOptions::get('params');

			if (any($params)) {
				foreach ($params as $param) {
					if (isset($list[$param])) {
						$sync[$param] = $list[$param];
					} else give_up(sprintf('Repository is not configured: %s', $param));
				}
			} else {
				$sync = $list;
			}

			out('Syncing local tree with remote repositories');
			\System\Cli::do_over($sync, function($repo, $url) {
				\System\Santa::sync_from($repo);
			});

			vout();
			self::updates();
		}


		/** Get list of all installed ya-packages
		 * @return void
		 */
		public static function installed()
		{
			\System\Init::basic();
			$packages = \System\Santa::get_all_installed();
			self::print_packages($packages);
			out(sprintf(l('Found %s installed packages.'), count($packages)));
		}


		/** Connect to mothership and check for new code
		 * @return array Set of updates
		 */
		public static function updates()
		{
			\System\Init::Basic();
			$updates = System\Santa::get_update_list();

			if (any($updates)) {
				out(sprintf(l('Updates available: %s'), count($updates)));

				self::print_packages($updates);
			} else {
				vout('No updates found');
			}
		}


		/** Get list of all available packages
		 * @return void
		 */
		public static function browse()
		{
			System\Init::basic();
			$packages = System\Santa::get_all();
			self::print_packages($packages);
		}


		/** Install a set of packages
		 * @return void
		 */
		public static function install()
		{
			System\Init::Basic();
			$params = YacmsCLIOptions::get('params');

			if (any($params)) {
				$packages = array();
				foreach ($params as $pkg_name) {
					if ($pkg = \System\Santa::find($pkg_name)) {
						$packages[] = $pkg;
					} else {
						out(sprintf(l('Package "%s" does not exist.'), $pkg_name));
						break;
					}
				}

				out(l('Following packages will be installed: '));

				foreach ($packages as $pkg) {
					$latest = explode('/', $pkg->get_latest_version());
				}

				out();
				if ($proceed = is_yes(read('Do you wish to proceed? '))) {
					self::hard_install($packages);
				}

				passthru(ROOT.'/bin/system'.(CLIOptions::get('verbose') ? ' -v':'').' htaccess');

			} else out(l('Please input package name or use --help'));
		}


		/** Print list of packages
		 * @return void
		 */
		private static function print_packages(array $packages)
		{
			foreach($packages as $pkg) {
				$available = $pkg->get_available();
				$print = array(
					'Description'        => $pkg->desc,
					'Homepage'           => $pkg->homepage,
					'Installed version'  => $pkg->is_installed() ? $pkg->get_installed_version():'',
				);

				$versions = array();

				foreach ($available as $version) {
					$ver  = &$versions[$version->repo][];
					$gray = $version->branch != 'stable' && $version->branch != 'unstable';
					$ver_str = $version->name;

					if ($pkg->is_installed() && $version->branch != System\Cli::term_remove_color('testing')) {
						$status = \System\Santa::greater_version_than($version->name, $pkg->get_installed_version());
						$color = 'normal';

						if ($status === true) $color = 'light_green';
						if ($status === false) $color = 'red';

						$ver_str = System\Cli::term_color($version->name, $color);
					}

					$ver = $ver_str.'-'.$version->branch;

					if ($gray) {
						$ver = System\Cli::term_color($ver, 'gray');
					}
				}

				foreach ($versions as $repo=>$packages) {
					if (any($packages)) {
						$print[sprintf('%s versions', ucfirst($repo))] = implode(', ', $packages);
					}
				}

				unset($ver);
				$status = '';

				if ($pkg->is_installed()) {
					$status = System\Cli::term_color('I', 'light_green');
				} else {
					$status = System\Cli::term_color('-', 'green');
				}

				out('['.$status.'] '.$pkg->get_full_name());
				out_flist($print, true, 4, false, 'green', true);
				out();
			}
		}


		/** Generate .gitignore and print it into STDOUT
		 * @return void
		 */
		public static function files()
		{
			\System\Init::basic();
			$params = CLIOptions::get('params');
			$files = Santa\Package::get_all_installed_files();
			$prefix = isset($params[0]) ? $params[0]:'';

			foreach ($files as $file) {
				out($prefix.substr($file['path'], strlen($prefix) == 0));
			}
		}


		/** Generate .gitignore and print it into STDOUT
		 * @return void
		 */
		public static function broken()
		{
			System\Init::Basic();
			$files = \Santa\Package::get_all_installed_files();
			$mod = $del = 0;

			foreach ($files as $file) {
				//out(ROOT.$file['path']);
				if (file_exists(ROOT.$file['path'])) {
					$sum = md5(file_get_contents(ROOT.$file['path']));
					if ($sum != $file['checksum']) {
						out("modified: ".$file['path']);
						$mod ++;
					}
				} else {
					out("deleted: ".$file['path']);
					$del ++;
				}
			}

			if ($mod || $del) {
				vout();
				if ($mod && $del) {
					vout("Total of ".$mod." modified and ".$del." deleted files");
				} elseif ($mod) {
					vout("Total of ".$mod." modified files");
				} else {
					vout("Total of ".$del." deleted files");
				}
			}
		}

		/** Update the system
		 * @return array Set of updates
		 */
		public static function upgrade()
		{
			System\Init::Full();
			$params = YacmsCLIOptions::get('params');
			$latest = YacmsCLIOptions::get('force');

			if (any($params)) {
				if ($latest) {
					out('Warning: selecting newest versions including testing branch. You should consider staying on one package branch, preferrably stable!');
					out();
				}

				$updates = array();
				foreach ($params as $pkg_name) {
					if (($pkg = Santa\Package::from_name($pkg_name)) instanceof Santa\Package) {
						if ($pkg->is_available_for_update(!$latest)) {
							$updates[] = $pkg;
						}
					} else {
						out(sprintf(l('Package "%s" does not exist.'), $pkg_name));
						exit(1);
					}
				}
			} else {
				$updates = Santa\Package::get_update_list(!$latest);
			}

			if (any($updates)) {
				out(l('Following packages will be upgraded:'));
				foreach ($updates as $pkg) {
					$old_branch = Santa\Cli::get_branch_color_text($pkg->branch.'/'.$pkg->version, $pkg->branch);
					list($newb, $newv) = explode('/', $new = $pkg->latest_version());
					$new_branch = Santa\Cli::get_branch_color_text($new, $newb);
					out(' ['.Santa\Cli::get_branch_color_text('U', $newb).'] '.$pkg->get_full_name().' ('.$old_branch.' -> '.$new_branch.')');
					out();

					$pkg->branch = $newb;
					$pkg->version = $newv;
				}

				if ($proceed = is_yes(read('Do you wish to proceed? '))) {
					self::hard_install($updates);
				}

				passthru(ROOT.'/bin/system'.(CLIOptions::get('verbose') ? ' -v':'').' htaccess');
			} else out(l('There are no upgrades for selected packages.'));

		}



		/** Install a set of packages
		 */
		private static function hard_install(array $packages)
		{
			System\Init::Basic();
			out(l('Installing packages ..'));
			$total = count($packages);

			$msg = 'Downloading packages';
			show_progress_cli(0, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			foreach ($packages as $key=>$pkg) {
				$pkg->download();

				if (!$pkg->downloaded) {
					out(sprintf(l('Failed to download package %s'), $pkg->name));
					exit(3);
				}

				show_progress_cli($key+1, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			}

			$msg = 'Extracting packages';
			show_progress_cli(0, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			foreach ($packages as $key=>$pkg) {
				$pkg->extract();

				if (!$pkg->extracted) {
					out(sprintf(l('Failed to extract package %s'), $pkg->name));
					exit(2);
				}

				show_progress_cli($key+1, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			}


			$msg = 'Checking for file conflicts';
			show_progress_cli(0, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			foreach ($packages as $key=>$pkg) {
				$result = $pkg->check_files();

				if (any($result)) {
					out_flist(array(
						"Path"    => $result['path'],
						"Package" => $result['package'],
						"Old"     => $result['old'],
						"New"     => $result['new'],
					));
					exit(1);
				}

				show_progress_cli($key+1, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			}

			$msg = 'Installing packages';
			show_progress_cli(0, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			foreach ($packages as $key=>$pkg) {
				$pkg->install();
				show_progress_cli($key+1, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			}

			$msg = 'Cleaning temporary files';
			show_progress_cli(0, 100, YacmsCLIOptions::get_con_width(), '', $msg);
			$files = array();
			$dirs  = array();
			read_dir_contents(ROOT.'/var/tmp', $files, $dirs);
			$total = count($dirs) + count($files);
			$x=0;

			foreach ($files as $file) {
				unlink($file);
				show_progress_cli($x++, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			}

			foreach ($dirs as $file) {
				rmdir($file);
				show_progress_cli($x++, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			}

			show_progress_cli($total, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			out();
			out('Done.');
		}
	}



// -- RUNTIME

	System\Init::cli();
