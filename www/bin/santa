#!/usr/bin/php
<?


// -- BASICS

	define("ROOT", realpath(__DIR__.'/..'));
	define("NAME", basename($_SERVER['SCRIPT_NAME']));

	require_once ROOT."/etc/init.d/pre-cli.php";
	require_once ROOT."/lib/include/core.cli.php";

// -- CLASSES

	// Options container
	abstract class CLIOptions extends YacmsCLIOptions
	{
		/* Override for console options parent
		 * @return void
		 */
		public static function init()
		{
			self::$opts = array(
				"env"   => array(
					"value" => false,
					"short" => 'e',
					"desc"  => 'Use this environment',
				),
				"force"   => array(
					"value" => false,
					"short" => 'f',
					"desc"  => 'Force action',
				),
				"help"   => array(
					"value" => false,
					"short" => 'h',
					"desc"  => 'Show this help',
				),
				"verbose" => array(
					"value" => false,
					"short" => 'v',
					"desc"  => 'Talkative mode',
				),
				"command" => array(
					"value" => null
				),
				"params"  => array(
					"value" => array()
				),
			);

			self::$commands = array(
				"branches"  => 'List all ya-package branches',
				"broken"    => 'List all ya-files that have been changed since install',
				"files"     => array(
					'single' => "List all installed files",
					'prefix' => "List all installed files with prefix",
				),
				"install"   => array(
					'packages' => "Install packages"
				),
				"installed" => 'Get list of installed ya-packages',
				"browse"    => 'Get list of all available packages',
				"updates"   => array(
					'single' => "Get list of available stable versions",
					'branch' => "Get list of available versions from this branch",
				),
				"update"    => ' Force reload package list',
				"upgrade"   => array(
					'single'   => "Upgrade all packages to the latest version",
					'packages' => "Upgrade packages",
//					'version'  => "Update to this version. Format: branch/version or branch/latest",
				),
			);

			self::$info = array(
				"name" => NAME,
				"head" =>
					'Santa package manager'.CR.
					'Internal package manager for YaWF system'.CR,

				"foot" => 'Santa will always skip upgrades from testing branch. It will also suggest upgrades only from packages\' branch'.CR,
			);
		}
	}


	abstract class CLICommands extends YacmsCLICommands
	{
		private static $branch_colors = array(
			'stable'   => 'light_green',
			'unstable' => 'yellow',
			'testing'  => 'light_red',
		);


		/** Get list of all installed ya-packages
		 * @return void
		 */
		public static function installed()
		{
			$packages = System\Package::get_all_installed();
			self::print_packages($packages);
			out(sprintf(l('Installed %s packages.'), count($packages)));
		}


		/** Get list of all available packages
		 * @return void
		 */
		public static function browse()
		{
			$branches = System\Package::get_tree();
			$packages = array();
			foreach ($branches as $bname => $branch) {
				foreach ($branch as $cname => $category) {
					foreach ($category as $pkg) {
						if (!isset($packages[$pkg['name']])) {
							$packages[$pkg['name']] = new System\Package(array(
								"name" => $cname.'/'.$pkg['name'],
								"desc" => $pkg['desc'],
								"homepage" => isset($pkg['homepage']) ? $pkg['homepage']:'',
								"available" => array(),
							));
						}

						$packages[$pkg['name']]->add_available($bname, $pkg['versions']);
					}
				}
			}

			self::print_packages($packages);
		}


		/** Print list of packages
		 * @return void
		 */
		private static function print_packages(array $packages)
		{
			foreach($packages as $pkg) {
				$available = $pkg->get_available();

				foreach ($available as &$ver) {
					list($branch, $version) = explode('/', $ver);

					if ($branch == 'testing') {
						$gray = true;
					}

					if ($pkg->installed && $branch != System\Cli::term_remove_color('testing')) {
						$status = System\Package::greater_version_than(System\Cli::term_remove_color($version), $pkg->version);
						$color = 'normal';

						if ($status === true) $color = 'light_green';
						if ($status === false) $color = 'red';

						$version = System\Cli::term_color($version, $color);
					}

					$ver = $branch.'/'.$version;

					if ($gray) {
						$ver = System\Cli::term_color($ver, 'gray');
					}
				}

				unset($ver);
				$status = '';

				if ($pkg->installed) {
					$status = System\Cli::term_color('I', 'light_green');
				} else {
					$status = System\Cli::term_color('-', 'green');
				}

				out('['.$status.'] '.$pkg->name);
				out_flist(array(
					'Description'        => $pkg->desc,
					'Installed version'  => $pkg->installed ? $pkg->branch.'/'.$pkg->version:'',
					'Available versions' => empty($available) ? 'none':implode(', ', $available),
					'Homepage'           => $pkg->homepage,
				), true, 4, false, 'green', true);
				out();
			}
		}


		/** Generate .gitignore and print it into STDOUT
		 * @return void
		 */
		public static function files()
		{
			$params = CLIOptions::get('params');
			$files = System\Package::get_all_installed_files();
			$prefix = isset($params[0]) ? $params[0]:'';

			foreach ($files as $file) {
				out($prefix.substr($file['path'], strlen($prefix) == 0));
			}
		}


		/** Generate .gitignore and print it into STDOUT
		 * @return void
		 */
		public static function broken()
		{
			$files = \System\Package::get_all_installed_files();
			$mod = $del = 0;

			foreach ($files as $file) {
				//out(ROOT.$file['path']);
				if (file_exists(ROOT.$file['path'])) {
					$sum = md5(file_get_contents(ROOT.$file['path']));
					if ($sum != $file['checksum']) {
						out("modified: ".$file['path']);
						$mod ++;
					}
				} else {
					out("deleted: ".$file['path']);
					$del ++;
				}
			}

			if ($mod || $del) {
				vout();
				if ($mod && $del) {
					vout("Total of ".$mod." modified and ".$del." deleted files");
				} elseif ($mod) {
					vout("Total of ".$mod." modified files");
				} else {
					vout("Total of ".$del." deleted files");
				}
			}
		}


		/** Connect to mothership and check for new code
		 * @return array Set of updates
		 */
		public static function updates()
		{
			$params = CLIOptions::get('params');
			$branch = isset($params[0]) ? $params[0]:null;
			$updates = System\Package::get_update_list($branch);

			if (any($updates)) {
				out(sprintf(l('Updates available: %s'), count($updates)));

				self::print_packages($updates);
			} else {
				vout($branch ? l('No updates found in branch "'.$branch.'"'):l('No updates found'));
			}
		}


		/** Update the system
		 * @return array Set of updates
		 */
		public static function upgrade()
		{
			$params = YacmsCLIOptions::get('params');
			$latest = YacmsCLIOptions::get('force');

			if (any($params)) {
				if ($latest) {
					out('Warning: selecting newest versions including testing branch. You should consider staying on one package branch, preferrably stable!');
					out();
				}

				$updates = array();
				foreach ($params as $pkg_name) {
					if (($pkg = System\Package::from_name($pkg_name)) instanceof System\Package) {
						if ($pkg->is_available_for_update(!$latest)) {
							$updates[] = $pkg;
						}
					} else {
						out(sprintf(l('Package "%s" does not exist.'), $pkg_name));
						exit(1);
					}
				}
			} else {
				$updates = System\Package::get_update_list(!$latest);
			}

			if (any($updates)) {
				out(l('Following packages will be upgraded:'));
				foreach ($updates as $pkg) {
					$old_branch = (System\Cli::term_color($pkg->branch.'/'.$pkg->version, self::$branch_colors[$pkg->branch]));
					list($newb, $newv) = explode('/', $new = $pkg->latest_version());
					$newbc = self::$branch_colors[$newb];
					$new_branch = (System\Cli::term_color($new, $newbc));
					out(' ['.System\Cli::term_color('U', $newbc).'] '.$pkg->name.' ('.$old_branch.' -> '.$new_branch.')');
					out();
					
					$pkg->branch = $newb;
					$pkg->version = $newv;
				}

				if ($proceed = is_yes(read('Do you wish to proceed? '))) {
					self::hard_install($updates);
				}
			} else out(l('There are no upgrades for selected packages.'));

		}


		/** Install a set of packages
		 * @return void
		 */
		public static function install()
		{
			$params = YacmsCLIOptions::get('params');
			if (any($params)) {
				$packages = array();
				foreach ($params as $pkg_name) {
					if (($pkg = System\Package::from_name($pkg_name)) instanceof System\Package) {
						$packages[] = $pkg;
					} else {
						out(sprintf(l('Package "%s" does not exist.'), $pkg_name));
						break;
					}
				}

				out(l('Following packages will be installed: '));

				foreach ($packages as $pkg) {
					list($branch, $ver) = explode('/', $pkg->latest_version());
					$pkg->version = $ver;
					$pkg->branch = $branch;
					out('  '.$pkg->name.'-'.$ver.($branch == 'stable' ? '':System\Cli::term_color(' ('.$branch.')', 'gray')));
				}

				out();
				if ($proceed = is_yes(read('Do you wish to proceed? '))) {
					self::hard_install($packages);
				}

			} else out(l('Please input package name or use --help'));
		}


		/** Get list of update channels
		 * @return void
		 */
		public static function branches()
		{
			$branches = System\Package::get_branch_list();
			vout(l('Available branches'));
			foreach ($branches as $branch) {
				out($branch);
			}
		}


		/** Force reload package tree
		 * @return void
		 */
		public static function update()
		{
			vout(l('Refreshing package tree and metadata ..'));
			System\Package::reload_tree();

			vout();
			self::updates();
		}


		/** Install a set of packages
		 */
		private static function hard_install(array $packages)
		{
			out(l('Installing packages ..'));
			$total = count($packages);

			$msg = 'Downloading packages';
			show_progress_cli(0, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			foreach ($packages as $key=>$pkg) {
				$pkg->download();

				if (!$pkg->downloaded) {
					out(sprintf(l('Failed to download package %s'), $pkg->name));
					exit(3);
				}

				show_progress_cli($key+1, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			}

			$msg = 'Extracting packages';
			show_progress_cli(0, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			foreach ($packages as $key=>$pkg) {
				$pkg->extract();

				if (!$pkg->extracted) {
					out(sprintf(l('Failed to extract package %s'), $pkg->name));
					exit(2);
				}

				show_progress_cli($key+1, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			}


			$msg = 'Checking for file conflicts';
			show_progress_cli(0, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			foreach ($packages as $key=>$pkg) {
				$result = $pkg->check_files();

				if (any($result)) {
					out_flist(array(
						"Path"    => $result['path'],
						"Package" => $result['package'],
						"Old"     => $result['old'],
						"New"     => $result['new'],
					));
					exit(1);
				}

				show_progress_cli($key+1, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			}


			$msg = 'Installing packages';
			show_progress_cli(0, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			foreach ($packages as $key=>$pkg) {
				$pkg->install();
				show_progress_cli($key+1, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			}

			$msg = 'Cleaning temporary files';
			show_progress_cli(0, 100, YacmsCLIOptions::get_con_width(), '', $msg);
			$files = array();
			$dirs  = array();
			read_dir_contents(ROOT.'/var/tmp', $files, $dirs);
			$total = count($dirs) + count($files);
			$x=0;

			foreach ($files as $file) {
				unlink($file);
				show_progress_cli($x++, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			}

			foreach ($dirs as $file) {
				rmdir($file);
				show_progress_cli($x++, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			}

			show_progress_cli($total, $total, YacmsCLIOptions::get_con_width(), '', $msg);
			out();
			out('Done.');
		}
	}




// -- RUNTIME

	require_once ROOT."/etc/init.d/cli.php";
