#!/usr/bin/php
<?

// -- BASICS

	define("ROOT", realpath(__DIR__.'/..'));
	define("NAME", basename($_SERVER['SCRIPT_NAME']));

	require_once ROOT."/etc/init.d/pre-cli.php";
	require_once ROOT."/etc/init.d/core.php";
	require_once ROOT."/lib/include/core.cli.php";

// -- CLASSES

	// Options container
	abstract class CLIOptions extends YacmsCLIOptions
	{
		/* Override for console options parent
		 * @return void
		 */
		public static function init()
		{
			self::$opts = array(
				"env"     => array(
					"value" => null,
					"short" => 'e',
					"desc"  => 'Use this environment',
					"type"  => 'string',
				),
				"force"   => array(
					"value" => false,
					"short" => 'f',
					"desc"  => 'Force action',
				),
				"help"   => array(
					"value" => false,
					"short" => 'h',
					"desc"  => 'Show this help',
				),
				"verbose" => array(
					"value" => false,
					"short" => 'v',
					"desc"  => 'Talkative mode',
				),
				"skip"    => array(
					"value" => false,
					"desc"  => 'Mark first migration ok and skip it',
				),
				"no-backups" => array(
					"value" => false,
					"desc"  => 'Make no backups during the process',
				),
				"command" => array(
					"value" => null
				),
				"params"  => array(
					"value" => array()
				),
			);

			self::$commands = array(
				"backup" => array(
					'single' => "Generate database backup to STDOUT",
					'path'   => "Save backup into file"
				),
				"drop"     => 'Drop database',
				"init"     => 'Create basic database with initial data',
				"info"     => 'Get some database information',
				"migrate" => array(
					'single' => "Process new migrations",
					'search' => "Process migrations like [param]",
				),
				"migrations" => array(
					'single' => "List migrations",
					'search' => "List migrations like [param]",
				),
				"purge"    => 'Delete all data from the database',
				"rebuild"  => 'Drop database and rebuild it from scratch',
				"reset"    => 'Reset database to default state',
				"restore"  => array(
					"single" => 'Check for saved backups and restore database',
					"path" => 'Read sql file and import it',
				),
				"save"     => 'Save database backup into standart path',
				"setup"    => 'Setup basic information to run database',
				"seed"     => 'Fill database with initial data if empty',
				"sync"     => array(
					"single"    => 'Sync database structure and contents',
					"structure" => 'Sync database structure',
					"relations" => 'Sync foreign keys',
					"data"      => 'Sync database contents',
				),
			);

			self::$forced_commands = array("purge");

			self::$info = array(
				"name" => NAME,
				"head" =>
					'Modify YaCMS database'.NL.
					'Read settings from your environment and perform action'.NL,

				"foot" =>
					'If no options are set, config is read from \$root/\$env'.NL,
			);
		}
	}


	// Execution container
	abstract class CLICommands extends YacmsCLICommands
	{
		/* Get some info about database
		 * @return void
		 */
		public static function info()
		{
			vout("Querying data ..");
			\System\Init::full();

			$db_list = cfg('database', 'list');
			foreach ($db_list as $db_ident => $db_cfg) {

				$size = System\Database::query("
					SELECT
							sum(data_length + index_length) 'size',
							sum( data_free ) 'free'
						FROM information_schema.TABLES
						WHERE table_schema = '".$db_cfg['database']."'
						GROUP BY table_schema;
				")->fetch();

				$mlast_date = false;
				$mcount = 0;

				try {
					$mig = System\Migration::get_new();
					$mcount = count($mig);
					$mlast = get_first("\System\Migration")->where(array("status" => 'ok'))->sort_by("updated_at DESC")->fetch();
					$stat = "Ok";

					if ($mlast) {
						$mlast_date = $mlast->updated_at;
					}
				} catch (System\Error $e) {
					$stat = "Migrating database is necessary.";
				}

				vout("");
				vout("YaCMS database info");

				out('Database '.$db_ident);
				sep();

				out_flist(array(
					"Driver"         => $db_cfg['driver'],
					"Host name"      => $db_cfg['host'],
					"Database name"  => $db_cfg['database'],
					"User"           => $db_cfg['username'],
					"Used charset"   => $db_cfg['charset'],
					"Lazy driver"    => $db_cfg['lazy'] ? 'yes':'no',
					"Size"           => System\Template::convert_value('information', $size['size']),
					"Free space"     => System\Template::convert_value('information', $size['free']),
					"Structure"      => $stat,
					"Last migrated"  => $mlast_date ? format_date($mlast_date, 'sql'):l('never'),
					"New migrations" => $mcount,
				));
				vout("");
				vout($mcount > 0 ? "We recommend running migrations":"All fine here");
			}
		}


		/* Get mysql dump
		 * @outputs a lot of crap
		 * @return void
		 */
		public static function backup($file = null)
		{
			\System\Init::full();
			$params = CLIOptions::get('params');
			if (isset($params[0])) {
				$file = $params[0];
			}

			$cmd = self::assemble_mysql_command("mysqldump", true);

			if (!is_null($file)) {
				shell_exec("mkdir -m775 -p ".dirname($file));
				$cmd .= " > ".$file;
			}

			passthru($cmd);
		}


		/* List available migrations
		 * @return void
		 */
		public static function migrations()
		{
			\System\Init::full();
			$params = CLIOptions::get('params');

			if (empty($params)) {
				$mig = System\Migration::get_new();
				array_reverse($mig);
				self::print_migrations($mig);
			} else {

				$mig = self::find_migrations($params[0]);
				if (any($mig)) {
					vout("Found ".count($mig)." migration".(count($mig) == 1 ? '':'s').":");
					vout("");
					self::print_migrations($mig);
				}
			}
		}


		/* Proceed with migrations
		 * @return void
		 */
		public static function migrate($backup = true)
		{
			\System\Init::full();
			$params = CLIOptions::get('params');

			if (empty($params)) {

				$mig = System\Migration::get_new();
				array_reverse($mig);

				if (any($mig)) {
					self::process_migrations($mig);
				} else vout("Did not find any usable migrations");

			} else {

				$mig = self::find_migrations($params[0]);
				if (any($mig)) {

					out("Found ".count($mig)." migration".(count($mig) == 1 ? '':'s').":");
					self::print_migrations($mig, $padding = 2);
					out("");

					if (!CLIOptions::get('force')) {
						out("Do you wish to proceed? (y/n) ", false);
						$str = trim(shell_exec("read str; echo \$str"));
					}

					if (CLIOptions::get('force') || in_array(strtolower($str), array("y", "1", "a"))) {
						self::save();
						self::process_migrations($mig);
					}
				} else out("Did not match any migration");
			}
		}


		/* Drop whole database structure
		 * @return void
		 */
		public static function drop()
		{
			\System\Init::full();

			if (self::database_exists()) {

				if (!CLIOptions::get('force')) {
					out("Are you sure you want to get rid of database? (yes/no) ", false);
					$str = trim(shell_exec("read str; echo \$str"));
				}


				if (CLIOptions::get('force') || is_yes($str)) {
					$db_ident = cfg('database', 'default');
					$db_name = cfg('database', 'list', $db_ident, 'database');

					self::save();
					out("Dropping database '".$db_name."'");
					$cmd = "echo \"DROP DATABASE \`".$db_name."\`\" | ".self::assemble_mysql_command('mysql');
					passthru($cmd);

					vout("She's dead, Jim.");
				}
			} else {
				vout('Database \'s already gone.');
			}
		}


		/* Drop whole database structure and rebuild it
		 * @return void
		 */
		public static function rebuild()
		{
			self::drop();
			self::database_create();
			self::database_init();
			self::sync();

			out("Rolling migrations ..");
			self::migrate(false);
		}


		/* Reset database to default state
		 * @return void
		 */
		public static function reset()
		{
			self::rebuild();
			out();
			self::seed();
		}


		/* Create database and fill it with initial data
		 * @return void
		 */
		public static function init()
		{
			self::database_create();
			self::sync();
			self::database_init();

			out();
			self::migrate(false);
			out();

			self::seed();
		}


		/* Restore database from backup
		 * @return void
		 */
		public static function restore()
		{
			\System\Init::basic();
			$params = CLIOptions::get('params');

			if (isset($params[0])) {
				if (file_exists($params[0])) {
					$db_ident = cfg('database', 'default');
					$db_name = cfg('database', 'list', $db_ident, 'database');
					vout("Restoring database '".$db_name."'");

					if (!self::database_exists()) {
						self::database_create();
					}

					self::import_sql($params[0]);
					out("Database restored");

				} else give_up("File not found!");
			} else {

				$backups = array();
				$files   = array();

				$d = opendir(ROOT."/var/backups");
				while ($f = readdir($d)) {
					if (strpos($f, ".") !== 0 && strpos($f, ".sql")) {
						$name = explode('_', $f);
						$backups[] = $name[0];
						$files[] = $f;
					}
				}

				rsort($backups);
				rsort($files);

				if (any($backups)) {
					out("Found these backups:");
					out_flist($backups, true, 2);
					out('');

					$key = CLIOptions::get('force') ? 0:read("Pick one [1-".count($backups)."]: ", false);

					if (array_key_exists($key, $backups)) {

						self::drop();
						self::database_create();

						out("Restoring to: ".$backups[$key]);
						self::import_sql(ROOT."/var/backups/".$files[$f]);
						out("Database restored");

					} else give_up("Invalid option.");
				} else give_up("Did not find any backups");
			}
		}


		/* Seed initial data to DB
		 * @return void
		 */
		public static function seed()
		{
			\System\Init::full();
			$data = System\Json::read_dist(ROOT.System\Database::DIR_INITIAL_DATA);
			out("Injecting initial data ..");

			foreach ($data as $model => $data_set) {
				$msg_work = substr($model, 0, 25).(strlen($model) > 25 ? '..':'');
				$x = 0;
				$total = count($data_set);
				show_progress_cli($x, $total, YacmsCLIOptions::get_con_width(), null, $msg_work);

				foreach ($data_set as $key => $tdata) {
					$x++;
					$tdata['is_new_object'] = true;

					$obj = new $model($tdata);
					$obj->save();

					foreach ($tdata as $attr=>$val) {
						if (is_array($val) && \System\Model\Database::attr_is_rel($model, $attr)) {
							if (\System\Model\Database::get_rel_type($model, $attr) == 'has-many') {
								$def = \System\Model\Database::get_rel_def($model, $attr);

								if (any($def['is_bilinear']) && any($def['is_master'])) {
									unset($obj->$attr);
									$obj->assign_rel($attr, $val);
								}
							}
						}
					}
					show_progress_cli($x, $total, YacmsCLIOptions::get_con_width(), null, $msg_work);
				}
			}
		}


		/* Save backup of database into standart path
		 * @return void
		 */
		public static function save()
		{
			if (!CLIOptions::get('no-backups')) {
				$db_ident = cfg('database', 'default');
				$db_name  = cfg('database', 'list', $db_ident, 'database');

				$file = ROOT."/var/backups/".str_replace(" ", "-", format_date(time(), "sql"))."_".$db_name.".sql";
				out("Creating backup of '".$db_name."' in '".$file."'");
				self::backup($file);
			}
		}


		/* Does db exist
		 * @return bool
		 */
		private static function database_exists()
		{
			$db_ident = cfg('database', 'default');
			$db_name  = cfg('database', 'list', $db_ident, 'database');

			$query = "SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '".$db_name."'";
			$cmd = "echo \"".$query."\" | ".self::assemble_mysql_command("mysql", false);
			$res = shell_exec($cmd);
			return !is_null($res);
		}


		/* Does db exist
		 * @param string $table
		 * @param string $column
		 * @return bool
		 */
		private static function table_column_exists($table, $column)
		{
			$db_ident = cfg('database', 'default');
			$name     = cfg('database', 'list', $db_ident, 'database');

			$query = "
			SELECT * FROM COLUMNS
				WHERE
					TABLE_NAME = '".$table."'
					AND COLUMN_NAME ='".$column."'
					AND TABLE_SCHEMA = '".$name."'";
			$cmd = "echo \"".$query."\" | ".self::assemble_mysql_command("mysql", false). " INFORMATION_SCHEMA";
			$res = shell_exec($cmd);
			return !is_null($res);
		}


		/* Create db
		 * @return void
		 */
		private static function database_create()
		{
			\System\Init::basic();

			$db_ident = cfg('database', 'default');
			$name     = cfg('database', 'list', $db_ident, 'database');

			out("Creating database '".$name."'");
			shell_exec("echo \"CREATE DATABASE ".$name."\" | ".self::assemble_mysql_command("mysql", false));
		}


		/* Create basic DB structure for saving migrations if not exists
		 * @return void
		 */
		private static function database_init()
		{
			\System\Init::full();

			$db_ident = cfg('database', 'default');
			$db_cfg = cfg('database', 'list', $db_ident);
		}


		/* Put together mysql call using options
		 * @return string
		 */
		private static function assemble_mysql_command($cmd, $db = false)
		{
			$db_ident = cfg('database', 'default');
			$db_cfg = cfg('database', 'list', $db_ident);

			$db_cfg['password'] && $cmd .= " -p".$db_cfg['password'];
			$db_cfg['username'] && $cmd .= " -u ".$db_cfg['username'];
			$db_cfg['host']     && $cmd .= " -h ".$db_cfg['host'];
			$db && $cmd .= ' '.$db_cfg['database'];

			return $cmd;
		}


		/* Print migrations to STDOUT
		 * @param array $mig   Set of migrations
		 * @param int $padding Left padding of the list
		 * @return void
		 */
		private static function print_migrations(array $mig, $padding = 0)
		{
			$pad = str_repeat(' ', $padding);
			foreach ($mig as $m) {
					out($pad.'['.format_date($m->date, 'sql-date').'] '.$m->name);
					vout($pad.'     Status: '.$m->status);
					vout($pad.'    MD5 sum: '.$m->md5_sum);
					vout($pad.'       Desc: '.$m->desc);
					vout('');
			}
		}


		/* Prepared search statement
		 * @param string $like String to match with
		 * @returns array      Set of matches migrations
		 */
		private static function find_migrations($like)
		{
			vout("Looking for migration described as ".$like." ..");
			return get_all("System\Migration")->where(array(
					"`id_database_migration` LIKE '%".$like."%'",
					"`name` LIKE '%".$like."%'",
					"`seoname` LIKE '%".$like."%'",
					"`md5_sum` = '".$like."'",
				), 't0', true)->fetch();
		}


		/* Run migrations on list
		 * @param array $mig  Set of migrations
		 * @return void
		 */
		private static function process_migrations(array $mig)
		{
			foreach ($mig as $m) {
				vout("Starting migration ".$m->md5_sum." ..");

				if (CLIOptions::get('skip')) {
					CLIOptions::set('skip', false);
					$m->status = 'ok';
					$m->save();
				} else {
					if ($m->status == 'ok' && !CLIOptions::get('force')) {
						$m->status = 'skipped ('.$m->status.')';
					} else {
						$m->run();
					}
				}

				CLIOptions::get('verbose') ?
					self::print_migrations(array($m)):
					out('  '.$m->md5_sum.': '.$m->status);
			}
		}


		/* Import SQL file into database
		 * @param string $file Path to file
		 * @return void
		 */
		private static function import_sql($file)
		{
			if (file_exists($file)) {
				shell_exec(self::assemble_mysql_command("mysql", true). " < ".$file);
			} else give_up("File not found: ".$file);
		}


		public static function setup()
		{
			return;
			$cfg = array(
				"host"     => read('Please enter SQL hostname'),
				"username" => read('Please enter SQL username'),
				"password" => read('Please enter SQL password', true),
				"database" => read('Please enter database name'),
			);
			// not implemented yet
			dump($cfg);
		}


		/** Sync database structure and contents
		 */
		public static function sync()
		{
			$params = CLIOptions::get('params');
			(empty($params) || in_array('structure', $params)) && self::sync_structure();
			(empty($params) || in_array('relations', $params)) && self::sync_relations();
		}


		public static function sync_structure()
		{
			\System\Init::full();
			\System\Loader::load_all();

			$models = \System\Model\Database::get_all_children();
			$msg_done = NULL;
			$msg_work = 'Syncing database structure';
			$x = 0;
			$total = count($models);

			show_progress_cli($x, $total, YacmsCLIOptions::get_con_width(), $msg_done, $msg_work);
			foreach ($models as $model) {
				show_progress_cli($x, $total, YacmsCLIOptions::get_con_width(), $msg_done, $model);
				\Database\Structure::sync_model($model);
				$x++;
			}
			show_progress_cli($total, $total, YacmsCLIOptions::get_con_width(), $msg_done, $msg_work);
		}


		public static function sync_relations()
		{
			out('Syncing foreign keys is not implemented yet');
		}
	}


// -- RUNTIME

	System\Init::cli();
